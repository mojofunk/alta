<?xml version="1.0" standalone="no"?>

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [

]>

<chapter id="ch-design">
  <title>Design</title>
  <section id="gui-interfaces">
    <title>GUI Interfaces</title>
    <para>
      Some elements of the GUI should be defined as interfaces and factory
      functions used to create instances so that different implementations
      can be used in certain areas.
    </para>

    <para>
      One situation where technique would be useful is for testing and or
      using different canvas implementations.
    </para>
  </section>

  <section id="server">
    <title>Server</title>
    <itemizedlist>
      <listitem>
        <para>
          The state of all objects is maintained on the server side.
        </para>
      </listitem>

      <listitem>
        <para>
          The clients can manipulate or query that state via the client API.
        </para>
      </listitem>

      <listitem>
        <para>
          The state of a project is stored and restored by the server.
        </para>
      </listitem>

      <listitem>
        <para>
          The gui state is not part of the project state and should probably
          be stored separately.
        </para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="client-api">
    <title>Client API</title>
    <para>
      All communication with the server/engine must go through the client
      API.
    </para>

    <para>
      One option for this would be to define a command class structure where
      a controller(gui in this case) creates a command containing a
      reference to the class and an operation to perform on that class(with
      arguments if any).
    </para>

    <para>
      Commands should not be created in gui code. Another interface should
      hide the implementation of command generation and asyncronous response
      etc.
    </para>

    <para>
      Each command would need a unique identifier generated by the client
      side for the server to use in the response?
    </para>

    <para>
      preferably the command interface would be very similar to libsigc++
    </para>

    <para>
      The client API should only communicate with the gui/controller via one
      thread.
    </para>

    <para>
      The controller must "connect" to the server and provide an object that
      can be used for communication. This "object" is used to ensure that
      any messages sent by the engine are executed in the thread of the
      gui/controller.
    </para>

    <para>
      When the server is in-process the command should not have to be
      converted from a functor with bound arguments etc. to some serialized
      form.
    </para>

    <para>
      Using an MVC pattern where the latency between updates to the model
      being reflected in the view is such that it effects the perceived
      responsiveness of the system may call for an alternate method where
      the view is updated immediately and the model is then updated
      asyncronously. Other views would still need to be notified by the
      server once the model is updated and the modifier would need to be
      notified if the update to the model was unsuccessful.
    </para>

    <para>
      If there are several client connections then there may need to be some
      mechanism for keeping the internal state of the clients consistant. If
      two clients send a modify command then one will succeed and the other
      will fail and a notification is sent to the client.
    </para>
  </section>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
	  href="interfaces.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
	  href="modules.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
	  href="serialization.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
	  href="filesystem_access.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
	  href="dataflow-processing.xml" />
  <section id="lifetime-management">
    <title>Object Lifetime Management</title>
    <para>
      The "business logic" of each class should be defined in an
      implementation class that should depend on as few libraries as
      possible.
    </para>

    <para>
      The private implementation(PIMPL) idiom could be used in conjunction
      with a thread safe smart pointer for access to objects from multiple
      threads.
    </para>

    <para>
      One idea would be for each class to use a boost::shared_ptr to hold a
      pointer to the member data so that objects are held/passed/copied by
      value and the internal reference counting of the shared_ptr
    </para>
  </section>

  <section id="patterns">
    <title>Patterns</title>
    <para>
      Some interesting articles/concepts on the www.c2.com pattern wiki that
      should be kept in mind.
    </para>

    <variablelist>
      <title>Useful Patterns</title>
      <varlistentry>
        <term>Memento</term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Command</term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Bridge</term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>

    <variablelist>
      <title>Patterns to Avoid</title>
      <varlistentry>
        <term>PrematureGeneralization</term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section id="class-overview">
    <title>Class Overview</title>
    <para>
      Most of these classes will be Abstract/Interfaces with factories to
      create instances of a particular implementation based on compile or
      runtime configuration.
    </para>

    <itemizedlist>
      <listitem>
        <para>
          Event
        </para>
      </listitem>

      <listitem>
        <para>
          Timeline
        </para>
      </listitem>

      <listitem>
        <para>
          Time
        </para>
      </listitem>

      <listitem>
        <para>
          Interval/Period
        </para>
      </listitem>

      <listitem>
        <para>
          Duration
        </para>
      </listitem>

      <listitem>
        <para>
          Clock
        </para>
      </listitem>

      <listitem>
        <para>
          AudioSource
        </para>
      </listitem>

      <listitem>
        <para>
          AudioFileSource
        </para>
      </listitem>

      <listitem>
        <para>
          AudioSink
        </para>
      </listitem>

      <listitem>
        <para>
          AudioFileSink
        </para>
      </listitem>

      <listitem>
        <para>
          BufferedAudioSource
        </para>
      </listitem>

      <listitem>
        <para>
          BufferedAudioSink
        </para>
      </listitem>

      <listitem>
        <para>
          Resampler
        </para>
      </listitem>

      <listitem>
        <para>
          Multiplexer
        </para>
      </listitem>

      <listitem>
        <para>
          Demultiplexer
        </para>
      </listitem>

      <listitem>
        <para>
          Amplifier
        </para>
      </listitem>

      <listitem>
        <para>
          Sequence
        </para>

        <para>
          I'm thinking that events in a sequence should not be able to
          overlap. If overlapping is desired then a Composition
        </para>
      </listitem>

      <listitem>
        <para>
          AudioSequence
        </para>
      </listitem>
    </itemizedlist>
  </section>
<!--
	<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" 
		href="Some_Subsection.xml" />
	-->
</chapter>
