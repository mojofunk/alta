<?xml version="1.0" standalone="no"?>

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [

]>

<chapter id="ch-design">
  <title>Design</title>
  <section id="gui-interfaces">
    <title>GUI Interfaces</title>
    <para>
      Some elements of the GUI should be defined as interfaces and factory
      functions used to create instances so that different implementations
      can be used in certain areas.
    </para>

    <para>
      One situation where technique would be useful is for testing and or
      using different canvas implementations.
    </para>
  </section>

  <section id="server">
    <title>Server</title>
    <itemizedlist>
      <listitem>
        <para>
          The state of all objects is maintained on the server side.
        </para>
      </listitem>

      <listitem>
        <para>
          The clients can manipulate or query that state via the client API.
        </para>
      </listitem>

      <listitem>
        <para>
          The state of a project is stored and restored by the server.
        </para>
      </listitem>

      <listitem>
        <para>
          The gui state is not part of the project state and should probably
          be stored separately.
        </para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="client-api">
    <title>Client API</title>
    <para>
      All communication with the server/engine must go through the client
      API.
    </para>

    <para>
      One option for this would be to define a command class structure where
      a controller(gui in this case) creates a command containing a
      reference to the class and an operation to perform on that class(with
      arguments if any).
    </para>

    <para>
      Commands should not be created in gui code. Another interface should
      hide the implementation of command generation and asyncronous response
      etc.
    </para>

    <para>
      Each command would need a unique identifier generated by the client
      side for the server to use in the response?
    </para>

    <para>
      preferably the command interface would be very similar to libsigc++
    </para>

    <para>
      The client API should only communicate with the gui/controller via one
      thread.
    </para>

    <para>
      The controller must "connect" to the server and provide an object that
      can be used for communication. This "object" is used to ensure that
      any messages sent by the engine are executed in the thread of the
      gui/controller.
    </para>

    <para>
      When the server is in-process the command should not have to be
      converted from a functor with bound arguments etc. to some serialized
      form.
    </para>

    <para>
      Using an MVC pattern where the latency between updates to the model
      being reflected in the view is such that it effects the perceived
      responsiveness of the system may call for an alternate method where
      the view is updated immediately and the model is then updated
      asyncronously. Other views would still need to be notified by the
      server once the model is updated and the modifier would need to be
      notified if the update to the model was unsuccessful.
    </para>

    <para>
      If there are several client connections then there may need to be some
      mechanism for keeping the internal state of the clients consistant. If
      two clients send a modify command then one will succeed and the other
      will fail and a notification is sent to the client.
    </para>
  </section>

  <section id="interfaces">
    <title>Interfaces</title>
    <para>
      Interfaces should be defined where possible so that modules
      implementing a particular interface can be loaded at runtime. This
      reduces compile time dependencies and allows for dummy modules to be
      used for testing if necessary.
    </para>

    <para>
      Ideally each class implementing a specific interface should be a
      separate module that is loaded at runtime. I think using a Factory
      pattern is an accepted way to do this.
    </para>

    <para>
      For the case of the AudioSource interface a dummy AudioSource could be
      written to generate a sine wave for signal testing.
    </para>

    <para>
      Interfaces should depend on as few non-primitive types as possible to
      decrease the class interdependence and increase the reusability.
    </para>

    <para>
      This pattern could be used for classes that read and or write audio
      data with possible interface names something like
      AudioSink/AudioOutputStream or AudioSource/AudioIStream.
    </para>

    <para>
      Implementations of AudioSource could use libsndfile or libaudiofile
      for instance any other combination of libraries to support reading of
      audio data.
    </para>

    <para>
      Audio Plugin frameworks like LADSPA and VST may also be supported by
      implementing a class that implements the AudioPlugin interface. The
      AudioPlugin interface acts as a Bridge so that the different types of
      plugins can be supported on different platforms. This abstraction also
      allows reuse of classes built on top of the interface like gui
      widgets.
    </para>

    <para>
      The base functionality of classes should assume a single thread model
      and not use locking. If a class is used in a multi-threaded
      environment then locking can be performed externally.
    </para>
  </section>

  <section id="serialization">
    <title>Serialization</title>
    <para>
      Unlike some other languages C++ doesn't have any built in support for
      serializing data structures/classes. So there is the choice of writing
      custom code or using an existing library. There are several
      serialization libraries including boost::serialization, s11n,
      Eternity.
    </para>

    <para>
      A common approach is to use templates, the only issue is that the
      serialization functions would then need to be defined in header files
      and be available at build time. With the boost library this may be a
      problem if an interface was needed for modules loaded at runtime to
      save thier state but I think it would be fair to have a requirement
      that either plugins save their own state and provide a means to
      restore them(presets for LADSPA plugins for instance) or provide
      enough access to internal data so that the state can be saved and
      restored as part of the application data.
    </para>

    <para>
      Requirements
    </para>

    <itemizedlist>
      <listitem>
        <para>
          Must be well tested.
        </para>
      </listitem>

      <listitem>
        <para>
          Cross platform i.e. Support for gcc and VC++ compilers etc.
        </para>
      </listitem>
    </itemizedlist>

    <variablelist>
      <title>Choices</title>
      <varlistentry>
        <term>Boost</term>
        <listitem>
          <para>
            requires RTTI
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section id="filesystem-access">
    <title>Filesystem Access</title>
    <para>
      An interface/abstract class could be written and then inheriting
      classes could use different libraries to implement the needed
      functionality. boost::filesystem and glib have most of the needed
      functionality but perhaps it would be better to use either directly.
      The only small issue with using Glib directly is that the API isn't as
      C++ish as boost.
    </para>

    <para>
      I think it would be better to use the boost libraries as the API is
      very good, seemingly well tested and more complete that the glib File
      Utilities.
    </para>

    <para>
      What might be worth defining an interface for would be the few
      miscellaneous functions provided by glib that are needed probably
      needed like:
    </para>
<screen>
g_get_home_dir
g_get_tmp_dir
g_get_user_name
g_get_real_name
etc
	 </screen>
  </section>

  <section id="dataflow-processing">
    <title>Dataflow and Processing</title>
    <variablelist>
      <title>Requirements</title>
      <varlistentry>
        <term>read-only</term>
        <listitem>
          <para>
            Graph structure must be read-only while processing. Meaning
            edges/connections cannot change while data is being processed by
            any of the vertices/nodes.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Few external dependencies</term>
        <listitem>
          <para>
            must have as little external dependencies as possible. Atomic
            primitives should probably be provided by a separate library.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Guaranteed completion</term>
        <listitem>
          <para>
            Graph processing must complete in a finite amount of time. i.e
            It is a directed acyclic graph.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>network</term>
        <listitem>
          <para>
            The high level audio interface should allow for data to be
            routed between processes or across a network with sample
            accurate syncronisation.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Library independence</term>
        <listitem>
          <para>
            The audio processing and graphing part of the implementation
            will also need to be accessible for internal processing which
            means it won't be able to depend on any particular audio
            library.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Multi-Threaded Processing</term>
        <listitem>
          <para>
            processing a graph must be able to occur in parallel using more
            than one thread, perhaps there should be a GraphProcessor
            interface that can have several implementations. For those cases
            where one thread processing the data is optimal then a
            NonThreadedGraphProcessor or perhaps GenericGraphProcessor can
            be used.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para></para>
  </section>

  <section id="lifetime-management">
    <title>Object Lifetime Management</title>
    <para>
      The "business logic" of each class should be defined in an
      implementation class that should depend on as few libraries as
      possible.
    </para>

    <para>
      The private implementation(PIMPL) idiom could be used in conjunction
      with a thread safe smart pointer for access to objects from multiple
      threads.
    </para>

    <para>
      One idea would be for each class to use a boost::shared_ptr to hold a
      pointer to the member data so that objects are held/passed/copied by
      value and the internal reference counting of the shared_ptr
    </para>
  </section>

  <section id="patterns">
    <title>Patterns</title>
    <para>
      Some interesting articles/concepts on the www.c2.com pattern wiki that
      should be kept in mind.
    </para>

    <variablelist>
      <title>Useful Patterns</title>
      <varlistentry>
        <term>Memento</term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Command</term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Bridge</term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>

    <variablelist>
      <title>Patterns to Avoid</title>
      <varlistentry>
        <term>PrematureGeneralization</term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section id="class-overview">
    <title>Class Overview</title>
    <para>
      Most of these classes will be Abstract/Interfaces with factories to
      create instances of a particular implementation based on compile or
      runtime configuration.
    </para>

    <itemizedlist>
      <listitem>
        <para>
          Event
        </para>
      </listitem>

      <listitem>
        <para>
          Timeline
        </para>
      </listitem>

      <listitem>
        <para>
          Time
        </para>
      </listitem>

      <listitem>
        <para>
          Interval/Period
        </para>
      </listitem>

      <listitem>
        <para>
          Duration
        </para>
      </listitem>

      <listitem>
        <para>
          Clock
        </para>
      </listitem>

      <listitem>
        <para>
          AudioSource
        </para>
      </listitem>

      <listitem>
        <para>
          AudioFileSource
        </para>
      </listitem>

      <listitem>
        <para>
          AudioSink
        </para>
      </listitem>

      <listitem>
        <para>
          AudioFileSink
        </para>
      </listitem>

      <listitem>
        <para>
          BufferedAudioSource
        </para>
      </listitem>

      <listitem>
        <para>
          BufferedAudioSink
        </para>
      </listitem>

      <listitem>
        <para>
          Resampler
        </para>
      </listitem>

      <listitem>
        <para>
          Multiplexer
        </para>
      </listitem>

      <listitem>
        <para>
          Demultiplexer
        </para>
      </listitem>

      <listitem>
        <para>
          Amplifier
        </para>
      </listitem>

      <listitem>
        <para>
          Sequence
        </para>

        <para>
          I'm thinking that events in a sequence should not be able to
          overlap. If overlapping is desired then a Composition
        </para>
      </listitem>

      <listitem>
        <para>
          AudioSequence
        </para>
      </listitem>
    </itemizedlist>
  </section>
<!--
	<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" 
		href="Some_Subsection.xml" />
	-->
</chapter>
