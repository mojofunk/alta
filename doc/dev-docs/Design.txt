Books

Code Complete

Coding Style

Coding Idioms

No multiple implementation inheritance(MII), prefer single implementation
inheritance(SII). This avoids possible problems and complexity associated with
MII such as virtual inheritance.

Gui

Each class that represents some aspect of the gui should be defined by an
interface(even if that is done after the fact) and no toolkit specific
structures should be exposed in the interface/public api. In theory it should
abstract the functionality so that any GUI toolkit could be used and the class
api would stay the same.

The gui and engine separation must communicate through an interface that would
allow for the engine to be located in a different process or even different
system.

Server

The state of all objects is maintained on the server side.

The clients can manipulate or query that state via the client API.

The state of a project is stored and restored by the server.

The gui state is not part of the project state and should probably
be stored separately.

The 

Client API

All communication with the server/engine must go through the client API.

One option for this would be to define a command class structure where
a controller(gui in this case) creates a command containing a reference to the
class and an operation to perform on that class(with arguments if any).

Commands should not be created in gui code. Another interface should hide the
implementation of command generation and asyncronous response etc.

Each command would need a unique identifier generated by the client side for
the server to use in the response?

preferably the command interface would be very similar to libsigc++

The client API should only communicate with the gui/controller via one
thread.

The controller must "connect" to the server and provide an object that can be used
for communication. This "object" is used to ensure that any messages sent by
the engine are executed in the thread of the gui/controller.

When the server is in-process the command should not have to be converted from
a functor with bound arguments etc. to some serialized form.

Using an MVC pattern where the latency between updates to the model being
reflected in the view is such that it effects the perceived responsiveness 
of the system may call for an alternate method where the view is updated 
immediately and the model is then updated asyncronously. Other views would
still need to be notified by the server once the model is updated and the
modifier would need to be notified if the update to the model was
unsuccessful.

If there are several client connections then there may need to be some 
mechanism for keeping the internal state of the clients consistant. 
If two clients send a modify command then one will succeed and the other
will fail and a notification is sent to the client. 


Interfaces should be defined where possible so that modules implementing
a particular interface can be loaded at runtime. This reduces compile
time dependencies and allows for dummy modules to be used for testing if
necessary.

Ideally each class implementing a specific interface should be a separate
module that is loaded at runtime. I think using a Factory pattern is an 
accepted way to do this.

For the case of the AudioSource interface a dummy AudioSource 
could be written to generate a sine wave for signal testing.

Interfaces should depend on as few non-primitive types as possible to
decrease the class interdependence and increase the reusability.

This pattern could be used for classes that read and or write audio
data with possible interface names something like AudioSink/AudioOutputStream or 
AudioSource/AudioIStream.

Implementations of AudioSource could use libsndfile or libaudiofile for
instance any other combination of libraries to support reading of audio
data.

Audio Plugin frameworks like LADSPA and VST may also be supported by 
implementing a class that implements the AudioPlugin interface. The AudioPlugin 
interface acts as a Bridge so that the different types of plugins can be 
supported on different platforms. This abstraction also allows reuse of 
classes built on top of the interface like gui widgets.

The base functionality of classes should assume a single thread model and not
use locking. If a class is used in a multi-threaded environment then locking
can be performed externally.

Serialization/Persistance

Unlike some other languages C++ doesn't have any built in support for 
serializing data structures/classes. So there is the choice of writing 
custom code or using an existing library. There are several serialization
libraries including boost::serialization, s11n, Eternity.

A common approach is to use templates, the only issue is that the 
serialization functions would then need to be defined in header files and
be available at build time. With the boost library this may be a problem 
if an interface was needed for modules loaded at runtime to save thier 
state but I think it would be fair to have a requirement that either plugins
save their own state and provide a means to restore them(presets for LADSPA
plugins for instance) or provide enough access to internal data so that 
the state can be saved and restored as part of the application data.

Requirements

 - Must be well tested.
 - Cross platform i.e. Support for gcc and VC++ compilers etc.

Boost
 - requires RTTI


Filesystem access

An interface/abstract class could be written and then inheriting 
classes could use different libraries to implement the needed functionality.
boost::filesystem and glib have most of the needed functionality but perhaps
it would be better to use either directly. The only small issue with using Glib
directly is that the API isn't as C++ish as boost.

I think it would be better to use the boost libraries as the API is very
good, seemingly well tested and more complete that the glib File Utilities.

What might be worth defining an interface for would be the few miscellaneous
functions provided by glib that are needed probably needed like:

g_get_home_dir
g_get_tmp_dir
g_get_user_name
g_get_real_name
etc

Dataflow and processing.

Requirements.

Graph structure must be read-only while processing. Meaning 
edges/connections cannot change while data is being processed by 
any of the vertices/nodes.

Graph processing must complete in a finite amount of time. i.e It is a 
directed acyclic graph.

must have as little external dependencies as possible. Atomic primitives
should probably be provided by a separate library.

The high level audio interface should allow for data to be routed between
processes or across a network with sample accurate syncronisation.

The audio processing and graphing part of the implementation will also need
to be accessible for internal processing which means it won't be able to 
depend on any particular audio library.

processing a graph must be able to occur in parallel using more than
one thread, perhaps there should be a GraphProcessor interface that can have 
several implementations. For those cases where one thread processing the data is
optimal then a NonThreadedGraphProcessor or perhaps GenericGraphProcessor can
be used.


Object Lifetime Management.

The "business logic" of each class should be defined in an implementation 
class that should depend on as few libraries as possible.

The private implementation(PIMPL) idiom could be used in conjunction with
a thread safe smart pointer for access to objects from multiple threads.

One idea would be for each class to use a boost::shared_ptr to hold a pointer
to the member data so that objects are held/passed/copied by value and the
internal reference counting of the shared_ptr


Some interesting articles/concepts on the www.c2.com pattern wiki that 
should be kept in mind.

PrematureGeneralization

Possible Patterns

Memento
Command
Bridge

Class overview

Some possible classes

Most of these classes will be Abstract/Interfaces with factories to create 
instances of a particular implementation based on compile or runtime 
configuration.

Event

Timeline

Time

Interval/Period

Duration

Clock

AudioSource 

AudioFileSource 

AudioSink 

AudioFileSink 

BufferedAudioSource 

BufferedAudioSink 

Resampler 

Multiplexer

Demultiplexer

Amplifier

Sequence

I'm thinking that events in a sequence should not be able to overlap. If
overlapping is desired then a Composition 

AudioSequence
